<!DOCTYPE html><html><title>musicdb</title><link rel="stylesheet" type="text/css" href="static/css/styles.css"><body><header><h1>musicdb</h1><p>Archive music using *nix</p></header><nav><ul><li><a href="index.html"><b>Home</b></a></li><li><a href="software.html">Software</a></li><li><a href="hardware.html">Hardware</a></li><li><a href="writing.html">Writing</a></li><li><a href="about.html">About</a></li><li><a href="contact.html">Contact</a></li></ul></nav><main><h2>Motivation</h2><p>Previously, my music library was managed by many files being mapped to many directories. A list of YouTube urls (*.ls) and youtube-dl's batchfile argument were used to download large libraries of music. The download script was very simple (see below), since youtube-dl was handling the for line in file structure for me. However, the process was entirely dependent on youtube-dl, which exits on any error (yes, even with -i passed). As a result, management of my music library was to be handled by my own script, which offers more control, being able to read my own formats and process my own file structure.</p><h2>Version One</h2><figure><code>filepath=`cd ~/music/ &amp;&amp; ls -dx1 */ | dmenu`<br/>filetype=`echo -e "mp3\nwav\nvorbis" | dmenu`<br/>listfile="${filepath%?}.ls"<br/>cd $filepath<br/>/usr/local/bin/youtube-dl --batch-file "~/music/$listfile" --extract-audio --audio-format $filetype --restrict-filenames<br/></code></figure><p>youtube-dl downloads all URLs in the file selected by dmenu.</p><h2>Version Two</h2><figure><code>FORMAT="mp3"<br/>FILE="music.db"<br/>while read -r line; do ID=$(printf "$line" | awk '{print $1}'); /usr/local/bin/youtube-dl --extract-audio --audio-format $FORMAT --restrict-filenames https://www.youtube.com/watch?v="$ID" &amp;&amp; grep -e "$ID" "$FILE" | awk '{print $1}' | xargs grep -r | cut -d'.' -f1 | awk '/music/{0; next} NF' | xargs mv *."$FORMAT"; done &#60; $FILE<br/></code></figure><p>Downloading a YouTube URL for each line in a file, then moving the resulting file to output directories.</p><h2>File Format</h2><p>The file format used by the download script requires that the YouTube video ID is in the column, and all consecutive fields are stored in tab-separated columns. The largest storage file (<a href="static/misc/music.db">music.db</a>) is formed by concatenating many smaller (.olst) files, the process of creating whch is described below.</p><p>Using the previous file format (a list of YouTube URLS, separated by newlines), use Vim or another capable text editor to isolate the ID part of the URL. In Vim, a command sequence such as "$10hd0" can be used. The longer lists in my library required the use of a macro, which was recorded on the first line, and applied to the remaining lines with "jVG:normal @q" where q was the name macro of the previous command. Writing this buffer, followed by using the paste utlity to merge the file with the ID list and a list of the files in each directory (ls -x1 | paste tmp.ulst &amp; tmp.olst) produces a file with an ID column and a file column, separated by tabs. The process of adding fields can be replicated with the previous command, substituting ls -x1 with a command of your choice.</p><figure><code>FILE=$1<br/>FORMAT=$2<br/>DIR=$(printf "$FILE" | awk -F . '{print $1}')<br/>LSFILE="$DIR/.ls"<br/>if [ ! -f "$LSFILE" ]<br/>then<br/>&nbsp;printf "Creating listfile $LSFILE\n"<br/>&nbsp;touch "$LSFILE"<br/>fi<br/>while read -r line<br/>do<br/>&nbsp;ID=$(printf "$line" | awk '{print $1}')<br/>&nbsp;MATCHES=$(grep "$ID" "$LSFILE")<br/>&nbsp;if [ -z "$MATCHES" ]<br/>&nbsp;then<br/>&nbsp;&nbsp;printf "Did not find match for $ID\n"<br/>&nbsp;else<br/>&nbsp;&nbsp;printf "Found match for $ID\n"<br/>&nbsp;fi<br/>done &lt; "$FILE"<br/>rm *."$FORMAT"<br/></code></figure><p>Set the output directory and create an archive file.</p><figure><code>yt-dlp --extract-audio --audio-format "$FORMAT" --restrict-filenames --age-limit 100 -R infinite https://www.youtube.com/watch?v="$ID"<br/></code></figure><p>Download just audio.</p><figure><code>printf "$ID" | xargs grep -r -- | cut -d'.' -f1 | awk '/music/{0; next} NF' | xargs -I {} cp -t {} *."$FORMAT" <br/></code></figure><p>Locate the output folder.</p><figure><code>cd $DIR &amp; ../rename.sh $ID &amp; cd .. &amp; printf "$ID\n" &gt;&gt; "$LSFILE"<br/></code></figure><p>Rename the output file.</p><figure><code>FILE=$1<br/>FORMAT=$2<br/>DIR=$(printf "$FILE" | awk -F . '{print $1}')<br/>LSFILE="$DIR/.ls"<br/>if [ ! -f "$LSFILE" ]<br/>then<br/>&nbsp;printf "Creating listfile $LSFILE\n"<br/>&nbsp;touch "$LSFILE"<br/>fi<br/>while read -r line<br/>do<br/>&nbsp;ID=$(printf "$line" | awk '{print $1}')<br/>&nbsp;MATCHES=$(grep "$ID" "$LSFILE")<br/>&nbsp;if [ -z "$MATCHES" ]<br/>&nbsp;then <br/>&nbsp;&nbsp;printf "Did not find match for $ID\n"<br/>&nbsp;&nbsp;yt-dlp --extract-audio --audio-format "$FORMAT" --restrict-filenames --age-limit 100 -R infinite https://www.youtube.com/watch?v="$ID" &amp; printf "$ID" | xargs grep -r -- | cut -d'.' -f1 | awk '/music/{0; next} NF' | xargs -I {} cp -t {} *."$FORMAT" &amp; cd $DIR &amp; ../rename.sh $ID &amp; cd .. &amp; printf "$ID\n" &gt;&gt; "$LSFILE"<br/>&nbsp;else<br/>&nbsp;&nbsp;printf "Found match for $ID\n"<br/>&nbsp;fi<br/>done &lt; "$FILE"<br/>rm *."$FORMAT"<br/></code></figure><p>Complete script which downloads each YouTube URL from the specified file.</p><h2>Rename Script</h2><figure><code>ID=$1<br/>FILE=`pwd | xargs -I {} find {} -type f | grep -- $ID`<br/>ARTIST=`pwd | sed "s:.*/::" | xargs -I {} grep -e $ID /home/hayden/media/music/{}.ls | awk -F'\t' '{print $2}' | tr '[:upper:]' '[:lower:]' | tr -d '&amp;' | tr -d '-' | tr -d "'"| tr ' ' '+' | sed 's/++/:/g' | sed 's/+/_/g' | sed 's/:/+/g'`<br/>TITLE=`pwd | sed "s:.*/::" | xargs -I {} grep -e $ID /home/hayden/media/music/{}.ls | awk -F'\t' '{print $3}' | tr '[:upper:]' '[:lower:]' | tr -d '(' | tr -d ')' | tr -d '.' | tr -d "'" | tr ' ' '+' | sed 's/++/:/g' | sed 's/+/_/g' | sed 's/:/+/g'`<br/>printf "$FILE\n"<br/>printf "$ARTIST\n"<br/>printf "$TITLE\n"<br/>read<br/>mv -i $FILE "$ARTIST-$TITLE"<br/></code></figure><p>Restrict filenames to lower-case only, with delimiters.</p><h2>Revisions and To-Do</h2><p>While testing the script, strings starting with a non-alphanumeric character, specifically the - character, cause the script to break. In either of the grep stages, these strings are instead processed as options, instead of being used as strings. The script is also extremely slow, due to the download and ffmpeg stages contained within youtube-dl (out of our control), and the recurive grep that occurs to find the correct folder.  </p></main><footer><ul><li><a href="#"><b>Top</b></a></li><li><a href="index.html"><b>Home</b></a></li><li><a href="software.html">Software</a></li><li><a href="hardware.html">Hardware</a></li><li><a href="writing.html">Writing</a></li><li><a href="about.html">About</a></li><li><a href="contact.html">Contact</a></li></ul></footer></body></html>
